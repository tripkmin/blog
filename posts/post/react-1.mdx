---
title: 리액트 정리
date: 2023-06-29
draft: true
series: React deep dive
techs:
  - React
---

## React를 사용하는 이유

- JS를 사용해 DOM을 변경시키는 과정의 예시
- 여기서 발생하는 주요 이슈
  - 일부분만 변경해야 할 때 ajax 요청으로 갱신을 할 수는 있겠지만
- React를 사용해 DOM을 변경시키는 과정의 예시
- 해결되는 문제점들

## 주요 파일

create-react-app을 통해 생성되는 파일 폴더 구조

```txt
my-app/
  README.md
  node_modules/
  package.json
  public/
    index.html
    favicon.ico
  src/
    App.css
    App.js
    App.test.js
    index.css
    index.js
    logo.svg
```

### index.js와 App.js

```js title="index.js"
import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<App />);
```

이 index.js가 페이지 로드시 **가장 먼저 실행**되는 파일임. 이게 그대로 실행되는 건 아니고 이 코드의 변형된 버전이 실행됨. createRoot라는 메서드를 호출해 React를 사용해 구축할 전체 UI의 메인 엔트리 포인트, 혹은 메인 훅을 생성함. 즉 React App의 시작점을 정의하고 createRoot를 사용해 엔트리 포인트[^2]를 생성하고, `<App />` 컴포넌트를 렌더링 하는 역할을 함.

### index.html

```html title="index.html"
<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/favicon.png" />
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <title>title</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
  </body>
</html>
```

이 단일 HTML 파일이 브라우저에서 로딩됨. 오직 이 HTML만 갖고 React App을 실행할 거임. 이런 SPA에서는 한 개의 HTML 파일만 사용하고 그 외 웹 페이지상의 모든 UI 변경은 React가 처리함. 이 HTML 파일 하나가 React가 관리하는 UI 전반이 렌더링 될 위치가 됨.

저 `#root`가 바로 React로 짠 코드들이 들어가 렌더링이 될 것임. createRoot의 역할은 React App이 렌더링 될 주된 위치라는 점을 알려줌. 이게 바로 createRoot의 역할.

### 추가

원래 CSS를 삽입하려면 이런식으로 했잖슴

```html
<link rel="stylesheet" href="대충_CSS_파일_경로"></link>
```

근데 JS에서 CSS를 삽입하려면(실은 안되지만) 이렇게 삽입함

```js
import './index.css';
```

## JSX

JSX는 실은 자바스크립트 XML을 의미함. 결국 HTML은 XML의 일종이기 때문.
목표 상태를 정의해놓고 그거에 맞춰서 알아서 변환해줌.
빌드 시 알아서 표준 JS 코드로 컴파일됨.

App.js는 index.js에서 렌더링되는 주요 구성 요소임을 의미함. 그리고 모든 컴포넌트들은 App.js 혹은 다른 컴포넌트 안에 중첩됨. 왜냐하면 리액트로 작업할 때 컴포넌트 트리를 만들게 되는데, 맨 위에 가장 중요한 App.js가 있고 그 아래에는 여러가지 커스텀 HTML 요소가 있음.(이게 사실상 컴포넌트). 여기서 가장 맨 위에 있는 컴포넌트만이 ReactDOM 렌더 지시로 HTML 페이지에 직접 렌더링 됨. 다른 하위 컴포넌트들은 ReactDOM의 직접 렌더링을 통해 렌더링되는 게 아니라 _컴포넌트의 HTML 코드 안에 있는 보통의 HTML 요소를 사용해 렌더링하게 됨._

리액트 프로그램에 있어서 이름 만들 때 컴포넌트는 대문자로 시작해야 함. 여러 단어를 쓰고 싶다면 CamelCase나 dash를 활용한 작명법을 사용. 컴포넌트명 역시도 대문자로 해야 함. 그래야 React가 컴포넌트임을 감지함. 만약 소문자로 시작한다면 이는 내장된 HTML 요소라 인식하기 때문.

리액트로 작성된 컴포넌트는 그냥 함수임. 함수를 호출하면 그냥 JSX를 반환하는 것임. 그러므로

중요한 규칙 중 하나. 반환하는 문장마다, 혹은 JSX 코드 조각마다 반드시 한 개의 루트 요소를 가져야 함. `<div></div>` 로 감싸든가, 저렇게 불필요한 요소 추가를 하고 싶지 않다면 `<></>`과 같은 것으로 감싸주면 됨. 이것을 `Fragment` 라고 하는데, 실제로는 아무런 HTML 요소도 아니지만 리액트 내에서 임시적으로 루트 요소임을 알려주기 위해 사용하는 가상 요소임. `<Fragment></Fragment>` 혹은 `<></>` 이렇게 쓸 수 있음.

class는 자바스크립트의 키워드로 인식해버리기 때문에 className property를 사용해 클래스를 정의해줘야 한다. [^3]

```jsx
const myFacialAge = 99;

return (
  <p>내 액면가: {myFacialAge}</p> // 내 액면가: 99 출력
);
```

## 컴포넌트

일반 페이지가 아닌 리액트 프로젝트의 경우 컴포넌트를 중심으로 돌아감.
리액트는 UI를 구축하는 자바스크립트 라이브러리라고 함. 이게 무슨 뜻인가?
HTML, CSS, JS 또한 UI를 구축하는 것이긴 함. 굳이 리액트 쓰는 이유는 간단하게 UI를 구축할 수 있기 때문. 아주 사소한 것들에 신경을 덜 쓸 수 있으니까. 리액트 같은 걸 사용하면 어떤 일이 발생했을 때 페이지를 업데이트 하는 로직보다 프로젝트를 구성하는 핵심 비즈니스 로직[^1]에 집중할 수 있음. 그게 리액트 쓰는 이유.

컴포넌트가 왜 중요한 개념인가. 왜 리액트에서는 컴포넌트가 사실상 다인가? 이건 모든 UI들이 컴포넌트로 구성되어 있기 때문임.

PostCard와 같은 UI는 구성은 같지만 내용이 좀 다름. 컴포넌트는 이런 구성들을 정의해놓고 그 안에 내용만 좀 다르게 넣을 수 있게 해서 재사용성을 극대화시킨 효과가 있음. 결국 다시말해 컴포넌트는 HTML, CSS, JS들의 결합으로 UI에 있어서 의미있는 한 부분들을 말한다고 보면 됨.

재사용이 가능하다는 것은 곧 프로그래밍에 있어 반복을 피할 수 있다는 얘기. 그리고 또 각 컴포넌트는 하나의 명확한 과제와 촛점에 대해서만 집중할 수 있음.

외부에서 가져온 로직을 함수에 넣고, 우려사항을 분리하고, 원한다면 같은 코드를 여러번 실행한다. 이게 함수의 개념임.

리액트는 컴포넌트를 만들기 위해 '선언적' 접근 방식을 사용하게 됨. 일반적인 자바스크립트 방식으로 하나하나 설명해줘야하는 '명령형' 접근 방식이 아님. 그래서 리액트로 작업할 때에는 원하는 최종 상태, 즉 목표 상태. 혹은 다양한 상황에 따라 다른 목표 상태를 j정의하는 것이 중요함. 일반 JS 처럼 직접 구체적인 DOM을 업데이트 하는 지침을 작성할 필요가 없는 대신 최종 상태, 그리고 특정 상황에서 특정 상태가 되어야 한다는 것을 정의해놓으면 됨.

### props

파라미터라는 구멍을 뚫어서 넣으면 구조는 같지만 내용은 각기 다른 컴포넌트를 생성할 수 있지 않겠음? 그리고 컴포넌트는 함수다. 그러므로 그런 특징을 활용해보자.

```jsx title="Wrapper" showLineNumber
export default function Wrapper({ title, children }) {
  return (
    <div className="wrapper">
      <h1>{title}</h1>
      {children}
    </div>
  );
}
```

```jsx title="App.js" showLineNumber
export default function App() {
  return (
    <Wrapper title="인사">
      <p>안녕하세요</p>
    </Wrapper>
  );
}
```

```HTML title="출력 결과" showLineNumber
<div class="wrapper">
  <h1>인사</h1>
  <p>안녕하세요</p>
</div>
```

작은 빌딩 블럭으로부터 UI를 구축하는 접근 방식을 Composition이라고 부름.

## 🔺createElement

(앞에꺼는 예전꺼 가져와서 설명하기)
이로써 아까 왜 JSX의 가장 상위요소는 하나였는지 설명이 될 수 있습니다.

만약 `<div></div> <div><div>` 이런 식으로 끝나게 되면 `React.createElement()`의 파라미터에 저 두 div를 동시에 집어넣을 방법이 없습니다. 배열 형태로 집어도 될 법 하겠지만 createElement의 인자에는 배열이 올 수 없습니다. 따라서 최상위 요소에 하나가 와야 하는 겁니다.

```jsx
React.createElement('button', null);
React.createElement('button', null);
```

이렇게가 안되기 때문에

```jsx
React.createElement(
  'div',
  null,
  React.createElement('button', null),
  React.createElement('button', null)
);
```

이런식으로 하는 것.

## 폴더 관리

컴포넌트다 싶어서 냅다 Components 폴더에 때려박는 게 아니라 컴포넌트의 성격에 따라 분리할 필요가 있습니다.

## 이벤트 핸들러

버튼을 예. Mozilia 들어가서 확인해보면 `<button>`을 조작할 수 있는 DOM interface가 `HTMLButtonElement`라고 되어있다.

![[Pasted image 20230629014457.png]]

여기서 HTMLButtonElement는 HTMLElement을 상속받은 하위 클래스, HTMLElement는 Element 클래스를 상속받은 하위 클래스... 이런 식으로 이어진다. 즉 HTMLButtonElement는 저 위의 모든 클래스들의 속성과 메서드를 사용할 수 있다는 얘기다.

JSX 요소에 이벤트 리스너를 달고 싶을 때에는 항상 on으로 시작하는 props를 가지고 이벤트 리스너를 부착시킨다. 예를 들어 button을 클릭했을 때 특정 함수가 실행되게 하고 싶은 경우에는 `<button onClick={()=>{console.log('마라샹궈')}}>` 이런 식으로 달 수가 있다. 그치만 JSX 안에 너무 많은 로직을 넣으면 가독성이 저해되므로 함수를 정의해서 그걸 그대로 onClick props 안에 넣어주는 편이다.

근데 왜 `<button onClick={console.log('마라샹궈')}>` 라던가, 혹은 `<button onClick={clickHandler()}` 처럼 하지 않는걸까?

---

**GPT 복사한거임, 이해하고 다시 적을 것**
정상적 상황 : 화살표 함수를 사용하여 `console.log('마라샹궈')`를 호출합니다. 이렇게 하면, 클릭이 발생할 때마다 새로운 함수 인스턴스가 생성되어 해당 로그를 출력합니다. 함수 인스턴스가 생성된다는 말은 JavaScript의 함수가 실행될 때마다 새로운 실행 컨텍스트가 생성된다는 것을 의미합니다.

JavaScript에서는 함수가 호출될 때마다 새로운 실행 컨텍스트가 스택에 푸시됩니다. 이 실행 컨텍스트는 함수의 실행에 필요한 모든 정보를 포함합니다. 여기에는 함수 내의 변수, 이 함수를 호출한 객체, 이 함수에서 반환해야 할 값 등이 포함됩니다.

위의 예에서 `onClick={()=>{console.log('마라샹궈')}}`는 함수를 정의하는 부분이며, 이 함수는 버튼을 클릭할 때마다 호출됩니다. 여기서 '새로운 함수 인스턴스가 생성된다'는 것은, 이 함수가 호출될 때마다 새로운 실행 컨텍스트가 생성되고, 이 실행 컨텍스트에서 `console.log('마라샹궈')`가 실행된다는 것을 의미합니다.

즉, 새로운 함수 인스턴스가 생성된다는 것은, 해당 함수의 실행에 필요한 새로운 환경(실행 컨텍스트)이 생성되고, 그 환경 내에서 함수의 코드가 실행된다는 것을 의미합니다.

---

1. `<button onClick={console.log('마라샹궈')}>`
   이게 바벨로 인해 해석되면 `React.createElement('button', {onClick: console.log('마라샹궈'})`가 될 거다. 이렇게 될 경우 버튼을 담은 컴포넌트가 로드되어서 버튼을 클릭했을 때가 아니라 버튼이 렌더링되는 시점에 바로 `console.log('마라샹궈')`가 실행되게 된다.

2. `onClick={clickHandler()}`
   이거 역시 똑같음
   (보충 필요)

---

만약 HTML 요소가 기본적으로 이벤트를 지원한다면 `on + 이벤트명`의 형태로 props를 추가해 이벤트 리스너를 달 수 있다.

보통 이런식으로 이벤트에서 트리거되고 핸들러 함수로 끝나는 경우가 많다.

## State

리액트의 동작 원리

- index.js에서 엔트리 포인트로 지정된 곳에 App.js가 렌더링됨
- App.js는 여러가지 하위 컴포넌트 코드들로 구성되어있음.
- 리액트는 그 하위 컴포넌트들을 하나하나 다 호출해서 JSX를 반환받음
- 이 일련의 과정들을 모두 마치고 난 뒤 전반적인 결과를 평가함
- 그걸 DOM 명령어로 번역 후 DOM에다가 반영시켜 렌더링함.

근데 문제는 리액트는 절대 반복하지 않는다는 것임. 즉 렌더링 되었을 때 위의 과정들을 실행하고 그 후에는 끝임. 근데 나는 화면에 보이는 걸 업데이트 하고 싶다. 그럴 때 쓰는 것이 State. 즉 특정 어떤 것이 변경되었고 특정 컴포넌트가 재평가되어야 한다고 말하는 문법.

이 기능을 사용하고 싶다면 `import { useState } from 'react'`를 해서 useState 함수를 불러와야 함. 컴포넌트 바깥에서 호출되거나, 혹은 중첩된 함수 안에서 호출할 수 없고 오직 컴포넌트 함수 안에서 직접적으로 호출되어야 함. 예외는 있긴 함. **(나중에 설명)**

> use로 시작하는 것들은 모두 훅임.

`const [name, setName] = useState('lee')`
저 두번째 set으로 시작하는 것으로 name을 바꿀 수 있음.
저걸 호출해서 값을 바꾸는 순간 리액트에게 state를 담고있는 컴포넌트의 재평가가 시급하다고 헬프콜을 때림.

```jsx
import { useState } from 'react';

export default function Test() {
  const [name, setName] = useState('lee');

  const clickHandler = () => {
    setName('kim');
    console.log(name);
  };

  return (
    <>
      <p>{name}</p>
      <button onClick={clickHandler}>이름 변경</button>
    </>
  );
}
```

위의 코드의 경우 버튼을 클릭하면 name이 바뀌기는 하지만 console.log(name)의 출력 값은 setName으로 바뀌기 이전의 state 값인 'lee'가 출력된다. 왜냐하면 state를 업데이트 하는 setName과 같은 함수들의 경우 바로 값을 바꾸지는 않고 state의 업데이트를 예약하기 때문임.

예를 들어 clickHandler의 함수가 요딴식으로 생겨먹었다고 가정해보자

```jsx
const clickHandler = () => {
  setName('kim');
  setName('park');
  setName('cha');
  setName('song');
  console.log(name);
};
```

만약 저런 setName이 호출되어 state가 변경되고 그 변경되는 즉시 컴포넌트를 재렌더링 하게 된다면 kim, park, cha, song으로 name이 변할 때마다 네 번의 렌더링이 발생하게 된다. 어차피 저 함수를 통해서 얻고 싶은건 name을 'song'으로 바꾼 한 번의 재렌더링이지 않은가. 그렇기 때문에 리액트에서는 set 함수로 state를 즉시 변경하는 게 아니라 예약(스케쥴링)해 성능을 최적화하고 일관성을 유지함. 이를 곧 batch update라고 칭함.

만약 강제로 업데이트 하고 싶다면 React 18 버전부터 추가된 flushSync()를 사용해 할 수 있음.

```jsx
export default function App() {
  return (
    <div>
      <Card name="lee" />
      <Card name="park" />
      <Card name="kim" />
    </div>
  );
}
```

```jsx
import { useState } from 'react';

export default function Card(props) {
  const [name, setName] = useState(props.name);
  const clickHandler = () => {
    setName('kim');
  };

  return (
    <>
      <p>{name}</p>
      <button onClick={clickHandler}>이름 변경</button>
    </>
  );
}
```

(저거를 실행한 결과 움짤)

Card라는 같은 컴포넌트를 참고해 렌더링 되었지만, 컴포넌트별 인스턴스를 기반으로 도립적인 state를 갖게되어 Card 컴포넌트 안에 정의된 state들은 자신만의 독립적인 state를 갖고 있다. 그래서 첫 번째 Card의 clickHandler를 작동시켰을 때 첫 번째 Card만 재렌더링 될 뿐 나머지 Card 컴포넌트는 그대로임. 왜냐하면 특정 인스턴스만 업데이트되고 나머지 다른 인스턴스는 상태 변화에 영향을 받지 않았기 때문임.
(여기서 컴포넌트 인스턴스는 특정 컴포넌트를 사용해 생성된 개별 엘리먼트를 말함. 컴포넌트 역시 일종의 틀임. 함수형이라서 조금 그렇지만 예전 class 문법에서는 이게 좀 더 직관적인 표현으로 와닿을 거임.)

---

근데 함수형 컴포넌트도 인스턴스라고 표현을 하는거니? 예전에 리액트에서 지원했던 클래스형 컴포넌트로 생성된 걸 보고 인스턴스라고 하는거면 이해가 가는데 함수형 컴포넌트에서도 인스턴스라는 말을 쓰는지 모르겠네

ChatGPT

JavaScript와 React에서 사용하는 '인스턴스' 개념은 약간 다릅니다. JavaScript에서 '인스턴스'는 클래스나 생성자 함수를 사용하여 생성된 객체를 의미합니다. 반면, React에서 '인스턴스'는 클래스 컴포넌트 또는 함수형 컴포넌트를 통해 생성된 개별 컴포넌트 엘리먼트를 의미합니다.

클래스형 컴포넌트에서 인스턴스는 더욱 명확하게 이해될 수 있습니다. 왜냐하면 JavaScript의 클래스에서 new 키워드를 사용하여 인스턴스를 생성하는 것과 유사하게, React 클래스 컴포넌트도 각기 다른 인스턴스를 생성하기 때문입니다. 이 경우, 각 인스턴스는 자체적인 상태(state)와 생명주기 메서드(lifecycle method)를 가집니다.

함수형 컴포넌트는 JavaScript 클래스가 아니지만, React의 컴포넌트 시스템 내에서 동일한 역할을 수행합니다. 함수형 컴포넌트의 각 호출은 효과적으로 새로운 '인스턴스'를 생성하며, 각 인스턴스는 독립적인 props, state, 그리고 hooks를 가집니다.

이렇게 설명하면, React에서 '인스턴스'라는 용어가 실제 JavaScript 객체 인스턴스와는 약간 다른 의미로 사용된다는 것을 이해하실 수 있을 것입니다. '인스턴스'라는 용어는 개별 컴포넌트 엘리먼트를 가리키는데, 이들 각각이 독립적인 상태와 동작을 가지는, 리액트 애플리케이션에서의 '인스턴스'를 의미하는 것입니다.

---

왜 const를 쓰느냐? useState()를 불러서 할당을 하는거임. `name = 'lee'` 이런 식으로 할당하지 않음. 그러므로 상수형으로 써도 괜찮음.

### 객체나 배열을 변경하고 싶을 때

```jsx
import { useState } from 'react';

export default function App() {
  // 이렇게 쓸 수도 있겠지만
  // const [name, setName] = useSTate('')
  // const [age, setAge] = useState(0)

  // 객체 형식으로 이렇게 묶었다고 쳐보자
  const [person, setPerson] = useState({
    name: '',
    age: 0,
  });

  const nameHandler = e => {
    setPerson({ ...person, name: e.target.value });
  };

  const ageHandler = e => {
    setPerson({ ...person, age: e.target.value });
  };

  return (
    <form>
      <input type="text" onChange={nameHandler} />
      <input type="number" onChange={ageHandler} />
    </form>
  );
}
```

이럴 경우 저 객체를 업데이트 하는 방법은 저렇게 원래 값을 spread 연산자를 통해서 붙여넣고 덮어쓰고 싶은 값을 뒤에다가 써서 오버라이딩 하면 됨.

근데 이전 상태를 고려해야 하는 상황에서는 저렇게 쓰는 대신 setState 함수 안에 콜백 함수를 집어넣어 이전 상태를 기준으로 상태변경을 보장하는 로직으로 작성해야 함.

```jsx
import { useState } from 'react';
export default function App() {
  const [state, setState] = useState(0);
}
const sum = () => {
  setState(state + 1);
  setState(state + 2);
  setState(state + 3);
  setState(state + 4);
};
const prevSum = () => {
  setState(prev => prev + 1);
  setState(prev => prev + 2);
  setState(prev => prev + 3);
  setState(prev => prev + 4);
};
return (
  <div>
    <p>결과: {state}</p>
    <button onClick={sum}>실행</button>
    // 실행시 4
  </div>
);
```

이전값을 적용해서 모든 값을 적용시키고 싶다면 prevSum처럼 해야함

```jsx
function personNameHandler(event) {
  setPerson({ ...person });
}
```

양방향 바인딩을 통해 유기적인 흐름을 만들어낼 수 있음. (ex: 제출 뒤 양식을 초기화시키고 싶을 때 state만 초기화 시켜버리면 알아서 양식 내용까지..)

## State + Props

만약 컴포넌트 구조가

- App
  - AddCardInput
  - Card

이렇다고 가정하자. 여기서 App에서 정의되어있는

```jsx
export default function App() {
  const [people, setPeople] = useState([
    { name: 'lee', age: 20 },
    { name: 'kim', age: 30 },
    { name: 'park', age: 40 },
  ]);

  return (
    <>
      <AddCardInput />
      {people.map((person, idx) => {
        <Card person={person} />;
      })}
    </>
  );
}
```

이렇게 되어있다고 치자. 여기서 AddCardInput 컴포넌트에서 상위 App 컴포넌트로 정보를 이동시키려면 어떻게 해야할까?

두 가지 방법이 있다.

1. App에 state를 만들어놓고 그걸 아래로 빼버리는 방법
2. AddCardInput에 핸들러 함수를 보내서 위로 빼내어 보내는 방법

```jsx
import { useState } from 'react';

export default function App() {
  const [people, setPeople] = useState([
    { name: 'lee', age: 20 },
    { name: 'kim', age: 30 },
    { name: 'park', age: 40 },
  ]);

  const savePersonDataHandler = personData => {
    setPeople(prev => [...prev, personData]);
  };

  return (
    <>
      <AddCardInput onSavePersonData={savePersonDataHandler} />
      {people.map((person, idx) => (
        <Card key={idx} person={person} />
      ))}
    </>
  );
}
```

```jsx
import { useState } from 'react';

export function AddCardInput({ onSavePersonData }) {
  const [name, setName] = useState('');
  const [age, setAge] = useState(0);

  const nameHandler = e => {
    setName(e.target.value);
  };

  const ageHandler = e => {
    setAge(e.target.value);
  };

  const submitHandler = e => {
    e.preventDefault();
    const personData = { name: name, age: age };
    onSavePersonData(personData);
    setName('');
    setAge(0);
  };

  return (
    <form onSubmit={submitHandler}>
      <input type="text" value={name} onChange={nameHandler} />
      <input type="number" value={age} onChange={ageHandler} />
      <button type="submit">제출</button>
    </form>
  );
}
```

## Presentational vs Stateful Components

```jsx title="app.jsx" showLineNumbers
import { useState } from 'react';
import AddCardInput from './AddCardInput';
import Card from './Card';
import './App.css';

function App() {
  const [people, setPeople] = useState([
    { name: 'lee', age: 20 },
    { name: 'kim', age: 30 },
    { name: 'park', age: 40 },
  ]);

  const savePersonDataHandler = personData => {
    setPeople(prev => [...prev, personData]);
  };

  return (
    <>
      <AddCardInput onSavePersonData={savePersonDataHandler} />
      {people.map((person, idx) => (
        <Card key={idx} person={person} />
      ))}
    </>
  );
}

export default App;
```

```jsx title="Card.jsx"
export default function Card({ person }) {
  return (
    <div>
      <p>이름: {person.name}</p>
      <p>나이: {person.age}</p>
    </div>
  );
}
```

여기서 App이나 AddCardInput과 같이 state가 존재하는 컴포넌트가 있는 반면, props를 받아 단순히 출력에만 기여하는 Card 컴포넌트와 같은 것들이 있음.
이렇게 state를 갖고있는 컴포넌트들을 Stateful, Smart 컴포넌트라고 부르고, state 없이 단순 출력에만 기여하는 컴포넌트들을 Stateless, Dumb, Presentational 컴포넌트라고 부름.

onClick과 같은 이벤트 리스너 프로퍼티에는 어떤 값을 전달해야 하나요?

- 이벤트가 발생했을 때 실행해야 하는 함수의 포인터

실행될 함수의 “포인터”를 onClick 등의 값으로 전달해야 합니다. 그러면 이벤트가 발생했을 때 “사용자를 대신하여” React가 함수를 실행합니다.

## map()을 활용한 코드 단축

- map 함수의 정의
- map 함수를 이용한 예시

#### (연구해야 됨) 왜 key를 넣어야 하는가?

[링크](https://velog.io/@yeonbot/React%EC%97%90%EC%84%9C-key%EC%9D%98-%EC%97%AD%ED%95%A0-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EB%A5%BC-%EB%8B%A4%EC%8B%9C%EA%B7%B8%EB%A6%AC%EB%8A%94-%EA%B3%BC%EC%A0%95)
쉽게 얘기하자면 리액트 라이브러리가 목록 요소를 올바르게 식별해서 조작하는 데 필요하기 떄문임.

## 조건문

조건을 단축하는 방법
name은 filteredName은 배열.

1. 삼항 연산자

```jsx
{
  filteredName.length === 0 ? <p>필터된 게 없슈</p> : <p>{/* 필터된 목록들 */}</p>;
}
```

2. && 연산자

```jsx
{filteredName.length === 0 &&
  // 필터된게 없다는 안내문
}
{filteredName.length > 0 &&
  // 필터된 목록들을 보여주기
}
```

3. 아예 JSX 문법 시작 전에 if로 미리 갈무리 쳐놓기

```jsx
let filterContents = <p>필터된 게 없슈</p>;

if (filteredName.length > 0) {
  filterContents = filterElements.map(/* 세부 내용 생략 */);
}

return (
  /* 생략 */
  { filterContents }
);
```

## state를 활용한 스타일링

```jsx
import React, { useState } from 'react';

import Button from '../../UI/Button/Button';
import './TodoInput.css';

const TodoInput = ({ onAddGoal }) => {
  const [enteredValue, setEnteredValue] = useState('');
  const [isValid, setIsValid] = useState(true);

  const TodoInputChangeHandler = e => {
    setIsValid(true);
    setEnteredValue(e.target.value);
  };

  const formSubmitHandler = event => {
    event.preventDefault();
    if (enteredValue === '') {
      setIsValid(false);
      return;
    }
  };

  return (
    <form onSubmit={formSubmitHandler}>
      <div className="form-control">
        <label>Course Goal</label>
        <input type="text" onChange={TodoInputChangeHandler} />
      </div>
      <Button type="submit">Add Goal</Button>
    </form>
  );
};

export default TodoInput;
```

이 코드의 가장 큰 문제: style을 직접 적용했기 때문에 우선순위가 바뀜. 요딴식으로 inline 스타일링하면 훗날의 내가 개고생하는 경우가 생김.

> CSS 우선순위: !important > style > id > class

### inline 형식으로 지정하기

```jsx
import React, { useState } from 'react';

import Button from '../../UI/Button/Button';
import './TodoInput.css';

const TodoInput = ({ onAddGoal }) => {
  const [enteredValue, setEnteredValue] = useState('');
  const [isValid, setIsValid] = useState(true);

  const TodoInputChangeHandler = e => {
    setIsValid(true);
    setEnteredValue(e.target.value);
  };

  const formSubmitHandler = event => {
    event.preventDefault();
    if (enteredValue === '') {
      setIsValid(false);
      return;
    }
  };

  return (
    <form onSubmit={formSubmitHandler}>
      <div className="form-control">
        <label style={!isValid ? { color: 'red' } : undefined}>Course Goal</label>
        <input
          style={!isValid ? { border: '1px solid red' } : undefined}
          type="text"
          onChange={TodoInputChangeHandler}
        />
      </div>
      <Button type="submit">Add Goal</Button>
    </form>
  );
};

export default TodoInput;
```

### className 탈부착 형식으로 바꾸기

```jsx
import React, { useState } from 'react';

import Button from '../../UI/Button/Button';
import './CourseInput.css';

const TodoInput = ({ onAddGoal }) => {
  const [enteredValue, setEnteredValue] = useState('');
  const [isValid, setIsValid] = useState(true);

  const TodoInputChangeHandler = e => {
    setEnteredValue(e.target.value);
  };

  const formSubmitHandler = event => {
    event.preventDefault();
    if (enteredValue === '') {
      setIsValid(false);
      return;
    }
    setIsValid(true);
    onAddGoal(enteredValue);
  };

  return (
    <form onSubmit={formSubmitHandler}>
      <div className={`form-control ${!isValid ? 'invalid' : ''}`}>
        <label>Course Goal</label>
        <input type="text" onChange={TodoInputChangeHandler} />
      </div>
      <Button type="submit">Add Goal</Button>
    </form>
  );
};

export default TodoInput;
```

## 전역 참조 ->; 부분 참조

```jsx
import './TodoInput.css';
```

이걸 해결하려면 두 가지 방식

1. TodoInput.module.css로 CSS 모듈화를 하던가
2. 아예 Styled Component 라이브러리를 사용해 CSS-in-JS 방식으로 전환하던가

[카카오웹툰 CssinJS, module css](https://fe-developers.kakaoent.com/2022/220210-css-in-kakaowebtoon/)

### CSS 모듈화

```jsx
import React, { useState } from 'react';
import styles from '/';

import Button from '../../UI/Button/Button';
import './TodoInput.css';

const TodoInput = ({ onAddGoal }) => {
  const [enteredValue, setEnteredValue] = useState('');
  const [isValid, setIsValid] = useState(true);

  const TodoInputChangeHandler = e => {
    setIsValid(true);
    setEnteredValue(e.target.value);
  };

  const formSubmitHandler = event => {
    event.preventDefault();
    if (enteredValue === '') {
      setIsValid(false);
      return;
    }
  };

  return (
    <form onSubmit={formSubmitHandler}>
      <div className="form-control">
        <label style={!isValid ? { color: 'red' } : undefined}>Course Goal</label>
        <input
          style={!isValid ? { border: '1px solid red' } : undefined}
          type="text"
          onChange={TodoInputChangeHandler}
        />
      </div>
      <Button type="submit">Add Goal</Button>
    </form>
  );
};

export default TodoInput;
```

### CSS in JS (Styled Components, Emotion ...)

대표적인 css-in-js 라이브러리인 [Styled Components](https://styled-components.com/) 를 중심으로 설명

```jsx
import React, { useState } from 'react';

import Button from '../../UI/Button/Button';
import './TodoInput.css';

const TodoInput = ({ onAddGoal }) => {
  const [enteredValue, setEnteredValue] = useState('');
  const [isValid, setIsValid] = useState(true);

  const TodoInputChangeHandler = e => {
    setIsValid(true);
    setEnteredValue(e.target.value);
  };

  const formSubmitHandler = event => {
    event.preventDefault();
    if (enteredValue === '') {
      setIsValid(false);
      return;
    }
  };

  return (
    <form onSubmit={formSubmitHandler}>
      <div className="form-control">
        <label style={!isValid ? { color: 'red' } : undefined}>Course Goal</label>
        <input
          style={!isValid ? { border: '1px solid red' } : undefined}
          type="text"
          onChange={TodoInputChangeHandler}
        />
      </div>
      <Button type="submit">Add Goal</Button>
    </form>
  );
};

export default TodoInput;
```

사용법만

```jsx
import React, { Fragment } from 'react';
import styled from 'styled-components';

const Button = styled.button`
  padding: 20px;
  border-radius: 10px;
  background-color: gray;
  border: 1px solid black;
  transition: background-color 1s;

  &:hover {
    background-color: white;
  }

  &:active {
    transform: scale(0.85);
  }

  ${props =>
    props.$primary &&
    `
		background-color: blue;
		color: white;
	`}
`;

export default function App() {
  return (
    <div>
      <Button>그냥 버튼</Button>
      <Button $primary>$primary인 버튼</Button>
    </div>
  );
}
```

## 에러 핸들링

컴파일 오류

Q. 아니 자바스크립트는 인터프리터 언어라매요. 컴파일은 C나 Java에서나 접할만한 단어 아닌가요?
A. 그건 자바스크립트 얘기고... 지금 이건 리액트잖아...
JSX에서 얘기했듯, JSX 문법은 개발자의 개발 편의성을 위해 syntax sugar가 첨가된 언어이지 자바스크립트가 아님. 그 뿐만 아니라 리액트 프로젝트로 짠 여러 경로의 css, js 등을 실제로 묶어주는 작업이 필요함. 이걸 갖고 컴파일이라 그럼.

break-point 하는 방법
소스 탭 들어가서 localhost:3000/static/js/(소스폴더경로)/src/

거기에 컴포넌트, css 다 모여있음. 거기서 선택한 후 breakpoint 찍으면 됨.

## 숙제

특징

- UI와 컴포넌트의 분리.
- 컴포넌트는 고유의 기능과 책임을 갖고 있어야 한다.

## JSX의 제한사항

### 부모요소는 오직 하나

루트 JSX의 요소는 반드시 1개여야 함. 값을 반환하거나 값을 변수 또는 상수 또는 속성에 저장하려면 그 값은 반드시 JSX 요소 한 개여야만 함. 그 아래에는 자식이 얼마나 오든 상관없는데, 최상위 부모는 반드시 하나만 있어야 함.

왜냐하면

```jsx
// 일반 JSX 컴포넌트
export default SomeComponent(){
  return (
    <div></div>
    <div></div>
  )
}

// 이게 Babel로 변환되면 이렇게 됨
return (
  React.createElement(div, null)
  React.createElement(div, null)
)
```

JS에서는 둘 이상을 반환할 수 없음. 만약 둘 이상을 반환하고 싶다면 배열에다 담아쓰든 해야 함. 그치만 배열에 담았다는 것은 return할 때 배열 하나만 리턴한다는 뜻. 즉 하나만 return 할 수 있음.

### JSX를 배열에 담아 쓸 수 있음.

```jsx
return [<p>안녕하세요</p>, <p>반갑습니다</p>];
```

하지만 이렇게 배열 안에 들어가있는 children 요소는 리액트가 판별하기 용이하지 않음. 그래서 반드시 key props을 붙여줘서 리액트 라이브러리가 식별할 수 있게 해줘야함.

여기서 map 함수를 사용했을 때 key props를 붙여줘야 하는 이유를 알 수 있음. map 함수는 안에 있는 것들을 반복해서 새로운 배열 형태로 반환해주는 것이었잖슴. 배열에서 key가 반드시 필요하기 때문에 key props를 갖다가 붙여버린것임.

그러므로 ~~깔끔하진 않지만~~ 이렇게 할 수 는 있음.

```jsx
return [<p key="1">안녕하세요</p>, <p key="2">반갑습니다</p>];
```

근데 굳이 이렇게 쓰는 것보다는 `<div>` 같은 것에다가 담아 쓰는게 훨씬 편하기 때문에 저런식의 활용은 거의 안 하는 편.

### Fragment

그치만 단순히 return할 요소를 하나로 묶어버리기 위해 `<div>`를 사용하다보면 불필요한 `<div>` 박스들이 생기게 되고 이는 syntax 적으로 보기 좋지 않고, 불필요한 HTML 요소가 너무 많다면 앱이 느려지는 경우도 생기게 될 것이고, 또 CSS가 엉켜버려 안그래도 없는 머리카락을 쥐어뜯게 생기게 됨.

```jsx
return (
  <div>
    <div>
      <div>
        <div>
          <p>아이고</p>
        </div>
      </div>
    </div>
  </div>
);
```

그래서 저런 식의 의미없는 `<div>`를 막기 위해 `<></>` 혹은 `<Fragment></Fragment>` 기능을 주어 컴포넌트를 감싸는 용도로 사용되고 실제 HTML 요소를 차지하지는 않게 할 수도 있음.

#### +Fragment의 원리

```jsx
export default function Frag({ children }) {
  return children;
}
```

```jsx
import Frag from './Components/Frag';

export default function App() {
  return (
    <Frag>
      <p>Frag 컴포넌트에 감싸져있습니다.</p>
    </Frag>
  );
}
```

![[Pasted image 20230702153903.png]]

여기서 `<div id="root">`는 index.html에 있는 기본 div 박스임.
이렇게 컴포넌트로 만들었지만 사실은 이 Frag는 리액트의 기본 기능으로 내장되어있음. 그게 바로 `<>` / `<Fragment>` 임

### Portal을 활용해 실제 렌더링 위치 바꾸기

리액트는 일종의 라이브러리, portal의 경우에는 reactDOM에서 사용가능한 기능임. 리액트의 state 관리, 컴포넌트 기능과 같은 로직들을 실제 웹 브라우저의 DOM과 엮기 위해서 사용하는 라이브러리가 reactDOM임. 그래서 리액트와 리액트 네이티브를 결합하면 브라우저가 아닌 앱 환경에서 실행시킬 수 있음.

필요한 것

1. 실제 렌더링 될 위치를 미리 만들어주기
2. 특정 요소를 그 위치에서 렌더링 하라고 알려주기

```jsx
import { createPortal } from 'react-dom';

createPortal(/* 컴포넌트 */, /* 렌더링 할 위치의 ID*)
```

```jsx
import { createPortal } from 'react-dom';

function Test() {
  return <p>App 파일에서 정의되었지만 실제로는 다른 곳에서 나타날겁니다</p>;
}

export default function App() {
  return (
    <div>
      <p>App 컴포넌트입니다.</p>
      {createPortal(<Test />, document.querySelector('#test'))}
    </div>
  );
}
```

```html title="index.html"
<body>
  <noscript>You need to enable JavaScript to run this app.</noscript>
  <div id="root"></div>
  <div id="test"></div>
</body>
```

실제 출력 결과는 다음과 같다.

```html title="실제 출력 결과"
<body>
  <noscript>You need to enable JavaScript to run this app.</noscript>
  <div id="root">
    <div><p>App 컴포넌트입니다.</p></div>
  </div>
  <div id="test"><p>App 파일에서 정의되었지만 실제로는 다른 곳에서 나타날겁니다</p></div>
</body>
```

다만 실제로 렌더링 되는 DOM에서만 createPortal 기능을 사용할 수 있음

## useRef

ref는 reference 즉 참조를 말함. 여러가지 기능들이 있지만 기본적으로DOM에 접근해서 그것들로 작업할 수 있게 해줌.

```jsx
import { useState } from 'react';

export default function App() {
  const [value, setValue] = useState('');
  const [list, setList] = useState([]);

  const submitHandler = e => {
    e.preventDefault();
    setList(prev => [...prev, value]);
    setValue(''); // initialize
  };

  return (
    <div>
      <form onSubmit={submitHandler}>
        <input
          type="text"
          value={value}
          onChange={e => {
            setValue(e.target.value);
          }}
        />
        <button type="submit">제출</button>
      </form>
      <ul>
        {list.map((el, idx) => (
          <li key={idx}>{el}</li>
        ))}
      </ul>
    </div>
  );
}
```

여기서 ref로 전환

```jsx
import { useRef, useState } from 'react';

export default function App() {
  const valueRef = useRef();
  const [list, setList] = useState([]);

  const submitHandler = e => {
    e.preventDefault();
    const valueInput = valueRef.current.value;
    setList(prev => [...prev, valueInput]);
    valueRef.current.value = '';
  };

  return (
    <div>
      <form onSubmit={submitHandler}>
        <input ref={valueRef} type="text" />
        <button type="submit">제출</button>
      </form>
      <ul>
        {list.map((el, idx) => (
          <li key={idx}>{el}</li>
        ))}
      </ul>
    </div>
  );
}
```

ref의 용도는 읽기 전용.
useRef훅을 호출 후 변수에 담아 그 변수를 JSX의 ref 속성에 담으면 실제 렌더링되어 나오는 DOM 과 직접적인 연결이 완성됨. 참고로 useState처럼 함수형 컴포넌트에서만 사용 가능. 초기화하려는 기본값이 필요한데 지금 여기서는 필요 없음. 어차피 없어졌다가 실제 ref를 마주쳤을 때 실제 DOM 노드가 그 안으로 들어갈거기 때문. 실제 DOM과 REACT 프로젝트와의 연결을 통해 뭔가를 해낼 수 있음. 즉 ref 안에 들어가는 값은 항상 객체. 그리고 그 객체 안에는 반드시 current property를 가짐.

이제 연결도 되었으니 조작을 할 법 하겠지만 **리액트에서는 useRef를 통해 값을 조작하는 것을 권장하지 않음.** DOM은 리액트 안에서만 조작되어야 불필요한 버그를 방지할 수 있고, 또 그 편이 훨씬 간편할 때가 많기 때문임. 그치만 읽는 것은 어느정도 사용해도 상관없기 때문에 여기서 한 번 써보기로 하자.

그럼 뭘 쓰느냐? 값의 변화에 민감하게 반응할 일이 없을때는 ref 써서 인풋 관리하는게 더 편할 수 있지만, 반대로 값의 변화에 좀 더 민감하게 반응하는 경우(ex: 아이디 길이가 허용 규격에 벗어날 경우 즉시 경고문을 띄우고 싶다던가, 비밀번호와 비밀번호 확인 필드가 일치할 때 경고문을 보내주고 싶다던가 등)에는 state를 활용하는 게 더 좋음.

#### Controlled vs Uncontrolled Components

ref를 사용해서 input을 제어한다던가 하는 경우에는 리액트가 제공하는 useState 훅을 통해서 제어를 하는 게 아니기 때문에 리액트로 직접 제어하는 게 아님. 그래서 uncontrolled components라고 말함. 보통 input components에 대해 얘기하는 경우에는 보통 form components에 대해 얘기하는 경우가 많음.

## UseEffect

JSX의 평가 뒤에 이 함수가 실행됨

```jsx
useEffect(
  () => {
    /* 실행시키고 싶은 코드 내용*/
    return () => {
      /* 위에 함수가 실행되기 전에 미리 실행하는 코드 내용 */
    };
  },
  [
    /* 여기에 state를 넣으면 특정 state가 업데이트 될때만 코드 실행*/
  ]
);
```

state의 변경에 따라서 뭔가를 하고 싶을 때 사용.

1. 의존성 배열에 아무것도 없을 경우 컴포넌트가 처음 실행될 때만 실행됨
2. 의존성 배열에 특정 변수가 있을 경우 아래 상황에서 실행됨
   1. 컴포넌트가 처음 실행될 때
   2. 의존성 배열 안의 변수 값이 바뀔 때
3. `return () => { 함수 }` 가 있다면 useEffect 함수 실행 전에 실행됨
   1. 이를 활용해 컴포넌트의 언마운트 시에 함수를 실행시킬 수도 있음.

만약 의존성 배열을 제거해버린다면

---

> 이거 `[]`랑 같게 들어가는거 같음.

```jsx
/* 잘못된 코드임! 따라치지 마셈*/
const [value, setValue] = useState(true);

useEffect(() => {
  setValue(prev => !prev);
});

/* 위의 코드는 아래와 같다 */
const [value, setValue] = useState(true);

setValue(prev => !prev);
```

React Hook useEffect contains a call to 'setValue'. Without a list of dependencies, this can lead to an infinite chain of updates. To fix this, pass [] as a second argument to the useEffect Hook react-hooks/exhaustive-deps
: deps 없이 useEffect 쓰면 재렌더링을 무한으로 즐기는 수가 있다는 뜻

- 컴포넌트 실행, value, setValue 초기화
- 이후 setValue를 true에서 false로 바꿈
- state가 바뀌었으니 컴포넌트 재렌더링
- 그리고 다시 setValue로 false → true
- 무한의 츠쿠요미

---

useEffect는 주로 Side Effect를 처리하기 위해 존재함. http request같은 거. 키 입력을 듣고 데이터를 저장하는 것, 그리고 그에대한 응답으로 다른 액션을 실행하는 것(유효성 검증)
무엇이든 어떤 액션에 대한 응답으로 실행되는 액션이 있다면 그것은 사이드이펙트임.
그 때 useEffect를 쓸 것.

```jsx
import { useEffect, useState } from 'react';

let myTimer;

const MyComponent = props => {
  const [timerIsActive, setTimerIsActive] = useState(false);

  const { timerDuration } = props; // using destructuring to pull out specific props values

  useEffect(() => {
    if (!timerIsActive) {
      setTimerIsActive(true);
      myTimer = setTimeout(() => {
        setTimerIsActive(false);
      }, timerDuration);
    }
  }, [timerIsActive, timerDuration]);
};
```

이 예에서:

- `timerIsActive` 는 **종속성으로 추가되었습니다.** 왜냐하면 구성 요소가 변경될 때 변경될 수 있는 구성 요소 상태이기 때문이죠(예: 상태가 업데이트되었기 때문에)
- `timerDuration` 은 **종속성으로 추가되었습니다.** 왜냐하면 해당 구성 요소의 prop 값이기 때문입니다 - 따라서 상위 구성 요소가 해당 값을 변경하면 변경될 수 있습니다(이 MyComponent 구성 요소도 다시 렌더링되도록 함).
- `setTimerIsActive` 는 **종속성으로 추가되지 않습니다.** 왜냐하면**예외 조건**이기 때문입니다: 상태 업데이트 기능을 추가할 수 있지만 React는 기능 자체가 절대 변경되지 않음을 보장하므로 추가할 필요가 없습니다.
- `myTimer` 는 **종속성으로 추가되지 않습니다.** 왜냐하면 그것은 **구성 요소 내부 변수가 아니기 때문이죠.** (즉, 어떤 상태나 prop 값이 아님) - 구성 요소 외부에서 정의되고 이를 변경합니다(어디에서든). **구성 요소가 다시 평가되도록 하지 않습니다.**
- `setTimeout` 은 **종속성으로 추가되지 않습니다** 왜냐하면 그것은 **내장 API이기 때문입니다.** (브라우저에 내장) - React 및 구성 요소와 독립적이며 변경되지 않습니다.

### clean up function, debouncing

```jsx
useEffect(() => {
  const identifier = setTimeout(() => {
    setisValid(enteredId.length > 5);
  }, 500);

  return () => {
    clearTimeout(identifier);
  };
}, [enteredId]);
```

```jsx
useEffect(() => {
  console.log('마운트');
  return () => {
    console.log('언마운트');
  };
}, []);
```

### Dependency 사용 시 주의점

객체형 데이터를 넣고 그 객체의 특정값이 변할 때 useEffect 문을 실행시키는 예시

```jsx
import React, { useEffect, useState } from 'react';

export default function App() {
  const [value, setValue] = useState({ name: 'lee', age: 20 });

  useEffect(() => {
    if (value.age > 40) {
      alert('당신은 MZ하지 못하군요');
    }
  }, [value.age]);

  return (
    <div>
      <button
        onClick={() => {
          setValue(prev => ({ ...prev, name: 'park' }));
        }}
      >
        이름 변경
      </button>
      <button
        onClick={() => {
          setValue(prev => ({ ...prev, age: 45 }));
        }}
      >
        나이 변경
      </button>
    </div>
  );
}
```

의도대로라면 나이 변경 버튼을 눌러야만 useEffect문의 함수를 띄워 인신공격을 할 수 있겠지만, 실제로는 이름만 변경해도 시비를 털어버리...는 줄 알았는데 잘되네?

```jsx
import React, { useEffect, useState } from 'react';

export default function App() {
  const [value, setValue] = useState({ name: 'lee', age: 20 });

  const { age } = value;

  useEffect(() => {
    if (age > 40) {
      alert('당신은 MZ하지 못하군요');
    }
  }, [age]);

  return (
    <div>
      <button
        onClick={() => {
          setValue(prev => ({ ...prev, name: 'park' }));
        }}
      >
        이름 변경
      </button>
      <button
        onClick={() => {
          setValue(prev => ({ ...prev, age: 45 }));
        }}
      >
        나이 변경
      </button>
    </div>
  );
}
```

---

## useReducer

useState로 인해 반환되는 `[state, setState]`는 state에 보관된 데이터, 그리고 그 데이터를 변경할 수 있는 set 함수만 가지고 있음. 여기서 state의 변경을 별도의 로직으로 빼서 관리할 수 있는데 그것이 바로 useReducer임.

```jsx
const [state, dispatch] = useRedcuer(reducer, initialState);
```

1. state는 useState처럼 그냥 state 자체를 의미
2. dispatch는 state 변경 로직을 호출하는 것임. setState처럼 직접 state를 변경하는 게 아니라 dispatch 안에 객체(?)를 담아 reducer에 정의된 로직에 맞게 state를 변경할 수 있는 중간자 역할을 함.
3. reducer는 dispatch안에 담긴 type을 보고 그 타입에 맞게 이런 저런 행동을 할 수 있도록 유도하는 일종의 신호수같은 느낌.
4. initialState는 state에 담기는 최초의 값이 무엇인지를 말함.

카운터의 예시

```jsx
// counterState의 초기 값을 결정함.
const counterInitialState = { count: 0 };

// counterDispatch에 담긴 타입에 맞게 특정 행동을 실행하도록 함
const counterReducer = (state, action) => {
  // state에는 counterState의 최신 state가 들어있음
  // action에는 counterDispatch의 소괄호 안에 들어있는 정보가 들어있음.
  switch (action.type) {
    case 'INCREMENT': // type의 경우 관습적으로 대문자로 작성함
      return { count: state.count + 1 };
    case 'DECREMENT':
      return { count: state.count - 1 };
    default:
      return state;
  }
};

const [counterState, counterDispatch] = useReducer(counterRedcuer, counterInitialState);
```

용도

1. state 자체가 좀 복잡할 때(객체 형식 등)

```jsx
const [state, dispatch] = React.useReducer(fetchUsersReducer, {
  users: [
    { name: 'John', subscribred: false },
    { name: 'Jane', subscribred: true },
  ],
  loading: false,
  error: false,
});
```

2. 서로 연관되어있는 state들을 묶어서 관리하는데 이전 상태를 참조해서 뭔가를 해야할 때
   (인강의 예시처럼 `setState(prev => )` 이걸로 해결 못하는 상황.)

```jsx
const [idValid, setIdValid] = useState(false);
const [enteredId, setEnteredId] = useState('');

const idChangeHandler = e => {
  setEnteredId(e.target.value);
  setIdvalid(enteredId.length > 5);
  // 여기서 문제 발생.
  // setIdValid에서 참조하는 enteredId가 바로 직전의 e.target.value가 아닐 수 있음
};
```

물론 useEffect를 사용해서 해결은 할 수 있음. 근데 로직을 깔끔하게 관리하고 싶으면 reducer가 더 좋긴 함. 특히 최신 상태를 유지해야함으로 인해 useEffect를 사용하는 경우에는 useReducer을써도 좋을때가 많음.

3. 뭔가 state를 변경하는 작업이 많은데 setState 특유의 batch적 특성때문에 의도하지 않은 버그를 미연에 방지하기 위해.
   state를 변경하는 reducer의 로직이 분리되어있기 때문에 테스트하기도 쉽다. 또 보기도 좋고

### 왜 reducer라는 말을 쓰는가?

배열을 다룰 수 있는 JS 함수 중에서 reduce 함수가 있다.

```jsx
const numbers = [1, 2, 3, 4, 5];

const sum = numbers.reduce((accumulator, currentValue) => {
  return accumulator + currentValue;
}, 0);

console.log(sum); // 출력: 15
```

> 리덕스에서 "reducer"는 이전 상태(previous state)와 액션(action)을 인자로 받아 다음 상태(next state)를 반환하는 순수 함수(pure function)입니다. 이러한 reducer 함수는 전체 애플리케이션의 상태를 업데이트하는 데 사용됩니다.

> Reducer 함수의 이름은 함수형 프로그래밍에서 "reduce" 연산을 나타내는 동사에서 유래했습니다. "reduce" 연산은 컬렉션(예: 배열)의 모든 요소를 순회하면서 단일 값으로 축소하는 연산입니다. 배열의 reduce 메서드를 예로 들면, reduce 메서드는 배열의 각 요소에 대해 reducer 함수를 실행하여 단일 값으로 줄입니다.

> Reducer 함수의 핵심 아이디어는 이전 상태와 액션을 받아서 다음 상태를 계산하는 것입니다. 이때 reducer 함수는 이전 상태를 변경하지 않고 새로운 상태를 반환해야 합니다. 이렇게 함으로써 리덕스는 상태 변이를 추적하고 예측 가능한 상태 변화를 유지합니다.

[MDN reduce 설명](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce)

### ContextAPI

props 맨날 빼고 조지는 그걸 보완하기 위해 만듬

개쉽게 설명

1. 일단 Context 보관함을 만든다 (형식적인 거라 생각)

```jsx title=""
import { createContext } from 'react';

const Context = createContext();

export default Context;
```

2. 만들어놓은 Context 보관함을 가지고 Provider 컴포넌트를 만들어준다. 그리고 여기서 Context 보관함에 저장할 것(함수도 가능)들을 `value` property에 넣어준다.

```jsx title="ContextProvider.jsx"
import { useState } from 'react';
import Context from './context';

export default function ContextProvider({ children }) {
  const [number, setNumber] = useState(1);
  return <Context.Provider value={{ number, setTest }}>{children}</Context.Provider>;
}
```

3. Context 보관함을 사용할 컴포넌트들을 ContextProvider로 래핑한다 (보통 App 전체를 래핑하는 편)

```jsx title="index.jsx"
import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';
import reportWebVitals from './reportWebVitals';
import ContextProvider from './store/ContextProvider';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <ContextProvider>
      <App />
    </ContextProvider>
  </React.StrictMode>
);

// If you want to start measuring performance in your app, pass a function
// to log results (for example: reportWebVitals(console.log))
// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals
reportWebVitals();
```

4. Context 보관함을 쓰고싶은 곳에서 아래와 같은 문법으로 꺼내 쓴다

```jsx
export default function App() {
  const ctx = useContext(Context);

  return (
    <>
      <button
        onClick={() => {
          console.log(ctx.number);
        }}
      >
        컨텍스트 숫자 출력
      </button>
      <button
        onClick={() => {
          setNumber(prev => prev + 1);
        }}
      >
        컨텍스트 숫자 1 더하기
      </button>
    </>
  );
}
```

추가) 1번 과정에서 createContext 소괄호 안에 더미 값을 집어넣어주면 자동완성이 쉽게 된다

```jsx
import { createContext } from 'react';

const Context = createContext({
  number,
  setNumber,
});

export default Context;
```

```jsx title="store/context.jsx"
import { createContext } from 'react';

const Context = createContext({
  id: '',
  isLoggedIn: false,
});

export default Context;
```

```jsx title="App.jsx"
import Test from './Components/Test/Test';
import Context from './store/context';

export default function App() {
  return (
    <Context.Provider
      value={{
        id: '',
        isLoggedIn: false,
      }}
    >
      <div>
        <Test />
      </div>
    </Context.Provider>
  );
}
```

```jsx title="Test.jsx"
import Context from '../../store/context';

export default function Test() {
  return (
    <Context.Consumer>
      {ctx => {
        console.log(ctx);
        return <div></div>;
      }}
    </Context.Consumer>
  );
}
```

#### Context.Consumer 대신 useContext로 쓰기

```jsx title="useContext"
import { useContext } from 'react';
import Context from '../../store/context';

export default function Test() {
  const ctx = useContext(Context);
  console.log(ctx);

  return <div></div>;
}
```

#### Context를 동적으로 만들어보자

## 예제 프로젝트

- 중괄호로 덮어쓰는 건 이걸 자바스크립트 표현식으로 평가하라... 라는 뜻
- parseInt("3") 이렇게 써도 되지만 +"3" 이렇게 써도 알아서 3으로 변환됨
- push 대신 concat을 사용하면 원본 변형없이

## Diffing 알고리즘

## Memo

(
부모 컴포넌트가 렌더링 되는데 아래 컴포넌트들은 그대로인 상황의 사진
근데 아래 컴포넌트가 개많은데 부모 컴포넌트가 렌더링된다는 이유만으로 다시 다 실행이 되는 구조의 사진
)

불필요한 자식 렌더링.

- 함수형 컴포넌트에서 가능, `export default React.memo(컴포넌트)` 이렇게 래핑하면 됨.

App이 변경될때마다 props에 전달된 값을 DemoOutput 컴포넌트에서 받아 비교. 기존 prop 저장, 변경 prop 저장. 그리고 비교.. 이것 역시 비용이 듬. 컴포넌트 트리가 매우 크다면 매우 괜찮은 최적화 방법일 수 있으나.. 자식 컴포넌트 트리가 크지 않고 매번 prop의 값이 바뀌는 경우라면 큰 의미 없음.

즉 불필요한 재평가를 잘라낸다..는 의미 느낌.

```jsx
export default function App() {
  const [state, setState] = useState(true);
  const clickHandler = () => {
    setState(prev => !prev);
  };

  return (
    <>
      <MemoDiv />
      <MemoButton onClick={clickHandler}>버튼</MemoButton>
    </>
  );
}
```

```jsx
export default function Div() {
  console.log('메모 DIV 실행됨');
  return <div>몽쉘</div>;
}

const MemoDiv = React.memo(Div);
```

```jsx
export default function Button({ onClick, children }) {
  console.log('메모 Button 실행됨');
  return <button onClick={onClick}>{children}</button>;
}

const MemoButton = React.memo(Button);
```

### 아니 근데 왜 버튼은 실행됨?

리액트에서 memo가 작동하는 원리는 이거임. 리액트는 state, props, 그리고 context가 변경될 때 리렌더링한다고 했음. 여기서는

```jsx
// App.jsx
const clickHandler = () => {
  setState(prev => !prev);
};
// ...
<MemoButton onClick={clickHandler}>버튼</MemoButton>;

// MemoButton.jsx
export default function Button({ onClick, children }) {
  // ...
}
```

여기서 이전과 props로 넘어온 onClick과 현재 onClick과의 비교를 하게 됨. 함수는 객체임 객체.
App이 리렌더링이 될 때마다 자바스크립트를 새로 실행하는 구조임. 자바스크립트를 새로 실행할 때 객체나 배열과 같은 참조값들은 메모리의 위치가 바뀌게 됨. (참조값들의 특징) 그러므로 이전 onClick 함수(객체)와 현재 onClick 함수(객체)의 내용은 같아보일지 모르지만 저장된 메모리 주소가 다르므로 다른 값이라는 판단이 나오므로 리렌더링이 실시되는 것임.

### 이런 한계를 극복하기 위한 useCallback()

```jsx
const clickHandler = useCallback(() => {
  setState(prev => !prev);
}, []); // []에 담았으니 절대 변경 안된다는 말
```

이렇게 useCallback에 함수를 넣게 되면 컴포넌트의 생성 시점에 한 번 실행되어 곧바로 React가 제공하는 함수보관함에 넣어지게 됨. 이는 함수의 포인터를 고정시켜 비교 작업시 동일하다는 것을 알려주기 위한 장치로써도 작용함

이렇게 함수 보관함에 넣는 작업을 함수를 캐싱한다, 혹은 메모이제이션한다, 혹은 콜백 캐시에 저장한다... 뭐 이런 식으로 얘기함.

근데 useEffect 마냥 뒤에 달려있는 저 배열은 뭐냐?

```jsx
export default function App() {
  const [age, setAge] = useState(23);

  const gettingOld = () => {
    setAge(prev => prev + 20);
  };

  const isMeMz = useCallback(() => {
    if (age < 40) {
      alert('이어폰을 꼽아야 능률이 오르군요');
    }
    if (age > 40) {
      alert('임플란트 가격을 알아봅시다');
    }
  }, []); // 제대로 작동하지 않음

  return (
    <>
      <p>현재 내 나이: {age}</p>
      <button onClick={gettingOld}>떡국 열 그릇 먹기</button>
      <button onClick={isMeMz}>MZ인지 확인하기</button>
    </>
  );
}
```

)

#### 클로저 개념

만약 저렇게 의존성 배열을 빈칸으로 해두면 함수를 처음 생성할 때 isMeMz에 사용하는 처음 컴포넌트가 렌더링되며 실행된 age값, 즉 23인 상태임. 여기서 useCallback없이 그냥 일반 함수로 묶어둔 상태로 age가 갱신되면 함수도 재실행되어 age값도 갱신된 값으로 바뀌겠지만, usecallback 안에 있다는 이유로 재실행되지 않은 함수는 age값이 그대로이게 됨. 혼자 과거속에 사는 느낌인거지. (색깔 컴포넌트, 흑백 컴포넌트 사진)

#### 근데 그러면 useState도 그래야 하는거 아님?

애초에 왜 useState나 useEffect나 이런 걸 왜 hook이라고 부를까? 컴포넌트의 라이프 사이클에 매달아서 뭔갈 실행한다.. 뭐 이런 거기도 하지만, 여기서는 리액트의 상태 관리 로직과 컴포넌트와의 연결을 의미하기도 함.**(뇌피셜임 확인 필요)**

리액트는 상태를 관리하고 컴포넌트와의 연결을 관리함. 그걸 반영하는 것은 reactDOM의 역할임. 여튼 리액트에서는 관리 프로세스의 일부로 useState와 여기에 전달된 기본값에 대해서는 첫 렌더링시에만 반영하도록 함. 그리고 그 상태가 어디 컴포넌트에서 나왔는지 기억해두고, 그 컴포넌트의 재평가시에는 useState 함수를 실행해서 새 상태를 생성하지 않음. 컴포넌트가 DOM에서 완전히 삭제되지 않는 이상 상태 초기화는 이뤄지지 않음. 다시말해 언마운트되었다가 다시 마운트되면 useState가 실행되어 초기화된다고 보면 됨.

컴포넌트의 재렌더링 시점과 상태 변경이 예약되는 시점을 아는 것이 중요함. setValue()로 인해 상태변경을 명령하는 코드를 짜도 이 코드가 읽힌 시점에서는 상태 변경이 아닌 **상태 변경을 예약하는 것임**. 따라서 컴포넌트가 렌더링 된 뒤 state가 변경되고 ,그로인해 또다시 렌더링이 발생하게 되는 것임. 그리고 상태변경이 여러가지가 있을 때 묶어서 처리하는 것을 batching이라 표현함.

```jsx
setValue(1);
setValue2(2);
// 위 둘은 같은 시점에 state 변경이 되고 실행됨
```

여튼 이렇게 컴포넌트에 있는 useState가 호출된 경우 재렌더링함

## useMemo()

useCallback이 함수 객체를 저장해서 컴포넌트가 재실행되어도 함수를 다시 생성하지 않고 그대로 가지고 있다가 특정 state가 변경되었을 때만 다시 생성되도록 할 수 있는 훅이라면, useMemo는 데이터를 저장함.

```jsx

```

정렬은 성능 비용이 많이 드는 작업. 저 item이 5개라서 망정이지 10억개가 있다고 상상해보자. 그리고 이걸 매번 컴포넌트가 재실행될 때마다 다시 sort 작업을 해야한다면 갑자기 00년대 조선컴으로 돌아가는 기분을 맛볼 수 있다.

아까 컴포넌트의 재렌더링 시 함수의 재생성을 막아 성능을 향상시켰던 것처럼, 데이터의 재생성도 막아 성능을 향상시킬 수 있는 방법이 있는데 그게 바로 `useMemo()`임.

```jsx
export default function App() {
  return (
    <div>
      <SomeComponents item={[1, 55, 90, 24, 8]} />
    </div>
  );
}

export default function SomeComponents({ item }) {
  const sortedItem = [...item].sort((a, b) => a - b);
  // 오름차순 정렬

  return (
    <div>
      {sortedItem.map(num => (
        <p>{num}</p>
      ))}
    </div>
  );
}

```

## 네트워크 사용

### DB에 직접 접근은 안함

프론트 단에서 DB에 직접 접근하게 되면 여러가지 문제가 발생할 수 있음. 브라우저에서 실행하는 모든 코드들은 난독화되어있기는 하나 마음만 먹으면 유저들이 읽을 수 있음. 그러다보니 만약 브라우저 측에서 DB에 직접 접근하는 코드를 짠다면 악성 유저가 그걸 가로채 DB를 조작하고 손상시킬 수 있음. 보안적으로 굉장히 좋지 않은 셈.

그렇기 때문에 우리는 DB를 직접적으로 접근하는 게 아니라 중간에 서버를 둬서 DB에 접근하는 로직을 뒷단에 숨기고, DB를 갖고 읽고, 쓰고, 수정하고, 삭제하는 행위를 서버측에 위임시켜, 약속된 행동을 하는 API를 만들어놓고 프론트는 그곳을 접근하는 방식으로 코드를 짜게 된다.

### 네트워크 접근 예제

https://swapi.dev/

playground에 올려놨음. 그거 가지고 설명할 것.

## 커스텀 훅

그냥 이것도 함수임. 근데 상태를 설정할 수 있는 로직을 포함한 함수인거임. 이걸 만들어서 재사용 가능한 함수에 상태를 설정하는 로직을 아웃소싱할 수 있음. 그냥 일반 함수와는 조금 다르게 useState, useReducer, useEffect등의 상태 관련 함수를 갖고 활용할 수 있음.

앞에 use를 붙여야 react 측에서 훅임을 알 수 있음.



---
---

- 컴포넌트 한, 두개 정도를 왔다갔다하는 이런 상황이면 문제가 없음
- 근데 컴포넌트 세, 네개를 넘어가는 props 전송은 개발자를 굉장히 곶통스럽게 함.
- 그걸 모를리가 없는 리액트 개발진은 Context라는 전역 state 보관함 같은 걸 사용해 props 전송없이 ContextProvider로 감싸진 곳에서는 해당 Context를 모두 이용 가능하도록 설정됨.


일단 createContext()로 context 보관함을 만든다.
```jsx
const Context = React.createContext();
```
그리고 Context 보관함을 갖다 쓸 수 있도록 Provider로 다른 컴포넌트를 감싼다. 
```jsx
export default function App(){
  return (
    <Context.Provider>
      /* 다른 여러 컴포넌트들 */
    </Context.Provider>
  )
}
```

그리고 Provider에 `value` props에다 내가 전달하고 싶은 값들을 정한다
```jsx
export default function App(){
  const [name, setName] = useState('lee')
  const [age, setAge] = useState(20)

  return (
    <Context.Provider value={ {name, age} }>
      /* 다른 여러 컴포넌트들 */
    </Context.Provider>
  )
}
```

그리고 저렇게 감싸진 컴포넌트 안에서 context 보관함을 사용하려면

```jsx
import Context from '@/src/store'

export default function DeepComponent(){
  const ctx = useContext(Context)

  return (
    <div>
      <p>{name}</p>
    </div>
  )
}
```




근데 실은 얘는 잘 안쓰고 redux나 jotai, zustand 같은 걸 쓰는데... 그 이유가 있다.
1. state를 변경하면 쓸데없는 컴포넌트들까지 전부 리렌더리링이 됨.

```jsx
import React, { createContext, useContext, useState } from 'react';

const MyContext = createContext();

const ParentComponent = () => {
  const [count, setCount] = useState(0);

  return (
    <MyContext.Provider value={count}>
      <ChildComponent />
    </MyContext.Provider>
  );
};

const ChildComponent = () => {
  const count = useContext(MyContext);
  console.log('ChildComponent rendering'); // 콘솔 로그 추가

  return <div>Count: {count}</div>;
};
```

여기서 ParentComponent만 변경했음에도 ChildComponent의 컴포넌트까지 재렌더링 됨. 

```jsx title="store/context.jsx"
import { createContext } from 'react';

const Context = createContext({
  id: '',
  isLoggedIn: false,
});

export default Context;
```
```jsx title="App.jsx"
import Test from './Components/Test/Test';
import Context from './store/context';

export default function App() {
  return (
    <Context.Provider
      value={{
        id: '',
        isLoggedIn: false,
      }}
    >
      <div>
        <Test />
      </div>
    </Context.Provider>
  );
}
```
```jsx title="Test.jsx"
import Context from '../../store/context';

export default function Test() {
  return (
    <Context.Consumer>
      {ctx => {
        console.log(ctx);
        return <div></div>;
      }}
    </Context.Consumer>
  );
}
```

#### Context.Consumer 대신 useContext로 쓰기
```jsx title="useContext"
import { useContext } from 'react';
import Context from '../../store/context';

export default function Test() {
  const ctx = useContext(Context);
  console.log(ctx);

  return (
    <div></div>;
  )
}
```

#### Context를 동적으로 만들어보자




## 성능 관련

### 리액트의 컨셉 설명

React는 UI를 만드는 자바스크립트 라이브러리고, 컴포넌트를 활용한다는 컨셉은 변하지 않음.  리액트 DOM은 웹에 대한 인터페이스인데, 리액트는 웹을 아예 모름. 컴포넌트만 어떻게 다루는 지 암. 리액트는 상태, 컴포넌트에만 집중하는 것임. 변화가 생기고 하는 그런 이벤트를 ReactDOM같은 곳에 전달하고, ReactDOM은 실제 DOM과 연결되어 유저에게 직접적으로 보이는 것을 관리함. 

Components에서 Props, Context, State가 변경되면 이를 사용하는 컴포넌트는 리액트를 통해 변경되면 . 리액트는 이 컴포넌트가 화면에 새로운 것을 그리려고 한다면 리액트 dom에다가 알려줘서 리액트DOM이 그걸 학 함.

 ---
해당 강의는 JavaScript 라이브러리인 React의 작동 방식에 대해 설명하고 있습니다. React의 핵심 개념들을 이해하는 것이 중요하다고 강조하면서, 컴포넌트, React DOM, 상태(State), props, 컨텍스트(Context) 등에 대해 설명하였습니다.

1. **컴포넌트**: React는 사용자 인터페이스를 구축하기 위해 컴포넌트라는 개념을 사용합니다. 컴포넌트는 사용자 인터페이스를 구성하는 개별 부품이며, 이를 통해 사용자 인터페이스를 효율적으로 구성하고 업데이트합니다.
    
2. **React DOM**: React DOM은 웹에 대한 인터페이스입니다. React 자체는 웹을 알지 못하며, 브라우저와도 직접적인 관계가 없습니다. React는 컴포넌트의 관리와 상태 객체 관리에 집중하며, 이에 대한 업데이트도 컴포넌트를 통해 이루어집니다. 실제 HTML 요소들이 화면에 어떻게 표시되는지는 React DOM이 관리합니다.
    
3. **상태(State) 및 Props**: React는 컴포넌트 내부의 데이터인 '상태'와 컴포넌트에 전달하는 데이터인 'props'를 관리합니다. 이들은 컴포넌트간의 상호작용을 가능하게 합니다.
    
4. **컨텍스트(Context)**: React는 컴포넌트 전체의 데이터인 '컨텍스트'도 다룹니다. 이를 통해 컴포넌트 간 데이터를 공유할 수 있습니다.
    

이러한 개념들이 변경되면, 해당 컴포넌트가 React를 통해 변경되고, React는 이 컴포넌트가 화면에 어떤 새로운 내용을 표시할지를 판단합니다. 이렇게 결정된 변경 사항은 React DOM에 전달되고, React DOM은 실제 화면에 이를 반영합니다.

React의 작동 방식의 핵심은 '가상 DOM'입니다. React는 가상 DOM을 사용하여 앱이 마지막으로 만든 컴포넌트 트리의 상태와 현재의 상태를 비교하고, 필요한 부분만 실제 DOM에 반영하여 성능을 향상시킵니다.

컴포넌트의 상태나 props, 컨텍스트가 변경되면 React는 컴포넌트 함수를 재실행하여 이를 재평가하며, 그 결과에 따라 필요한 부분만 실제 DOM에 업데이트합니다. 이렇게 React는 컴포넌트와 실제 DOM 사이의 효율적인 통신을 통해 화면을 빠르게 업데이트하고 성능을 향상시킵니다. ---



---

[^1]: 핵심 비즈니스 로직이 뭐지?
[^2]: 코드가 시작될 때 실행이 시작되는 파일. 가장 먼저 지나치는 통로같은 느낌.
[^3]: attribute와 property

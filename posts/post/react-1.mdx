---
title: 리액트 정리
date: 2023-06-29
draft: true
series: React deep dive
techs:
  - React
---

## 컴포넌트 중심의 리액트

일반 페이지가 아닌 리액트 프로젝트의 경우 컴포넌트를 중심으로 돌아감. 리액트는 UI를 구축하는 자바스크립트 라이브러리라고 함. 이게 무슨 뜻인가?

HTML, CSS, JS 또한 UI를 구축하는 것이긴 함. 굳이 리액트 쓰는 이유는 간단하게 UI를 구축할 수 있기 때문. 아주 사소한 것들에 신경을 덜 쓸 수 있으니까. 리액트 같은 걸 사용하면 어떤 일이 발생했을 때 페이지를 업데이트 하는 로직보다 프로젝트를 구성하는 핵심 비즈니스 로직[^1]에 집중할 수 있음. 그게 리액트 쓰는 이유.

컴포넌트가 왜 중요한 개념인가. 왜 리액트에서는 컴포넌트가 사실상 다인가? 이건 모든 UI들이 컴포넌트로 구성되어 있기 때문임.

PostCard와 같은 UI는 구성은 같지만 내용이 좀 다름. 컴포넌트는 이런 구성들을 정의해놓고 그 안에 내용만 좀 다르게 넣을 수 있게 해서 재사용성을 극대화시킨 효과가 있음. 결국 다시말해 컴포넌트는 HTML, CSS, JS들의 결합으로 UI에 있어서 의미있는 한 부분들을 말한다고 보면 됨.

재사용이 가능하다는 것은 곧 프로그래밍에 있어 반복을 피할 수 있다는 얘기. 그리고 또 각 컴포넌트는 하나의 명확한 과제와 촛점에 대해서만 집중할 수 있음.

외부에서 가져온 로직을 함수에 넣고, 우려사항을 분리하고, 원한다면 같은 코드를 여러번 실행한다. 이게 함수의 개념임.

리액트는 컴포넌트를 만들기 위해 '선언적' 접근 방식을 사용하게 됨. 일반적인 자바스크립트 방식으로 하나하나 설명해줘야하는 '명령형' 접근 방식이 아님. 그래서 리액트로 작업할 때에는 원하는 최종 상태, 즉 목표 상태. 혹은 다양한 상황에 따라 다른 목표 상태를 정의하는 것이 중요함. 일반 JS 처럼 직접 구체적인 DOM을 업데이트 하는 지침을 작성할 필요가 없는 대신 최종 상태, 그리고 특정 상황에서 특정 상태가 되어야 한다는 것을 정의해놓으면 됨.

index.js

```js title="index.js"
import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<App />);
```

이 index.js가 페이지 로드시 **가장 먼저 실행**되는 파일임. 이게 그대로 실행되는 건 아니고 이 코드의 변형된 버전이 실행됨. createRoot라는 메서드를 호출해 React를 사용해 구축할 전체 UI의 메인 엔트리 포인트, 혹은 메인 훅을 생성함. 즉 React App의 시작점을 정의하고 createRoot를 사용해 엔트리 포인트[^2]를 생성하고, `<App />` 컴포넌트를 렌더링 하는 역할을 함.

```html title="index.html"
<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/favicon.png" />
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <title>title</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
  </body>
</html>
```

이 단일 HTML 파일이 브라우저에서 로딩됨. 오직 이 HTML만 갖고 React App을 실행할 거임. 이런 SPA에서는 한 개의 HTML 파일만 사용하고 그 외 웹 페이지상의 모든 UI 변경은 React가 처리함. 이 HTML 파일 하나가 React가 관리하는 UI 전반이 렌더링 될 위치가 됨.

저 `#root`가 바로 React로 짠 코드들이 들어가 렌더링이 될 것임. createRoot의 역할은 React App이 렌더링 될 주된 위치라는 점을 알려줌. 이게 바로 createRoot의 역할.

?
원래 CSS를 삽입하려면 이런식으로 했잖슴

```html
<link rel="stylesheet" href="대충_CSS_파일_경로"></link>
```

근데 JS에서 CSS를 삽입하려면(실은 안되지만) 이렇게 삽입함

```js
import './index.css';
```

## JSX

JSX는 실은 자바스크립트 XML을 의미함. 결국 HTML은 XML의 일종이기 때문.
목표 상태를 정의해놓고 그거에 맞춰서 알아서 변환해줌.
빌드 시 알아서 표준 JS 코드로 컴파일됨.

App.js는 index.js에서 렌더링되는 주요 구성 요소임을 의미함. 그리고 모든 컴포넌트들은 App.js 혹은 다른 컴포넌트 안에 중첩됨. 왜냐하면 리액트로 작업할 때 컴포넌트 트리를 만들게 되는데, 맨 위에 가장 중요한 App.js가 있고 그 아래에는 여러가지 커스텀 HTML 요소가 있음.(이게 사실상 컴포넌트). 여기서 가장 맨 위에 있는 컴포넌트만이 ReactDOM 렌더 지시로 HTML 페이지에 직접 렌더링 됨. 다른 하위 컴포넌트들은 ReactDOM의 직접 렌더링을 통해 렌더링되는 게 아니라 _컴포넌트의 HTML 코드 안에 있는 보통의 HTML 요소를 사용해 렌더링하게 됨._

리액트 프로그램에 있어서 이름 만들 때 컴포넌트는 대문자로 시작해야 함. 여러 단어를 쓰고 싶다면 CamelCase나 dash를 활용한 작명법을 사용. 컴포넌트명 역시도 대문자로 해야 함. 그래야 React가 컴포넌트임을 감지함. 만약 소문자로 시작한다면 이는 내장된 HTML 요소라 인식하기 때문.

리액트로 작성된 컴포넌트는 그냥 함수임. 함수를 호출하면 그냥 JSX를 반환하는 것임. 그러므로

중요한 규칙 중 하나. 반환하는 문장마다, 혹은 JSX 코드 조각마다 반드시 한 개의 루트 요소를 가져야 함. `<div></div>` 로 감싸든가, 저렇게 불필요한 요소 추가를 하고 싶지 않다면 `<></>`과 같은 것으로 감싸주면 됨. 이것을 `Fragment` 라고 하는데, 실제로는 아무런 HTML 요소도 아니지만 리액트 내에서 임시적으로 루트 요소임을 알려주기 위해 사용하는 가상 요소임. `<Fragment></Fragment>` 혹은 `<></>` 이렇게 쓸 수 있음.

class는 자바스크립트의 키워드로 인식해버리기 때문에 className property를 사용해 클래스를 정의해줘야 한다. [^3]

```jsx
const myFacialAge = 99;

return (
  <p>내 액면가: {myFacialAge}</p> // 내 액면가: 99 출력
);
```

### props

파라미터라는 구멍을 뚫어서 넣으면 구조는 같지만 내용은 각기 다른 컴포넌트를 생성할 수 있지 않겠음? 그리고 컴포넌트는 함수다. 그러므로 그런 특징을 활용해보자.

```jsx title="Wrapper" showLineNumber
export default function Wrapper({ title, children }) {
  return (
    <div className="wrapper">
      <h1>{title}</h1>
      {children}
    </div>
  );
}
```

```jsx title="App.js" showLineNumber
export default function App() {
  return (
    <Wrapper title="인사">
      <p>안녕하세요</p>
    </Wrapper>
  );
}
```

```HTML title="출력 결과" showLineNumber
<div class="wrapper">
	<h1>인사</h1>
	<p>안녕하세요</p>
</div>
```

작은 빌딩 블럭으로부터 UI를 구축하는 접근 방식을 Composition이라고 부름.

## 🔺createElement

<HoverLink title="how-it-works-JSX">JSX가 어떤식으로 동작하는가</HoverLink>
(앞에꺼는 예전꺼 가져와서 설명하기) 이로써 아까 왜 JSX의 가장 상위요소는 하나였는지 설명이
될 수 있습니다.

만약 `<div></div> <div><div>` 이런 식으로 끝나게 되면 `React.createElement()`의 파라미터에 저 두 div를 동시에 집어넣을 방법이 없습니다. 배열 형태로 집어도 될 법 하겠지만 createElement의 인자에는 배열이 올 수 없습니다. 따라서 최상위 요소에 하나가 와야 하는 겁니다.

## 폴더 관리

컴포넌트다 싶어서 냅다 Components 폴더에 때려박는 게 아니라 컴포넌트의 성격에 따라 분리할 필요가 있습니다.

## 이벤트 핸들러

버튼을 예. Mozilia 들어가서 확인해보면 `<button>`을 조작할 수 있는 DOM interface가 `HTMLButtonElement`라고 되어있다.

![230629_032613_react-1](/posts/postImg/230629_032613_react-1.png)

여기서 HTMLButtonElement는 HTMLElement을 상속받은 하위 클래스, HTMLElement는 Element 클래스를 상속받은 하위 클래스... 이런 식으로 이어진다. 즉 HTMLButtonElement는 저 위의 모든 클래스들의 속성과 메서드를 사용할 수 있다는 얘기다.

JSX 요소에 이벤트 리스너를 달고 싶을 때에는 항상 on으로 시작하는 props를 가지고 이벤트 리스너를 부착시킨다. 예를 들어 button을 클릭했을 때 특정 함수가 실행되게 하고 싶은 경우에는 `<button onClick={()=>{console.log('마라샹궈')}}>` 이런 식으로 달 수가 있다. 그치만 JSX 안에 너무 많은 로직을 넣으면 가독성이 저해되므로 함수를 정의해서 그걸 그대로 onClick props 안에 넣어주는 편이다.

근데 왜 `<button onClick={console.log('마라샹궈')}>` 라던가, 혹은 `<button onClick={clickHandler()}` 처럼 하지 않는걸까?

---

**GPT 복사한거임, 이해하고 다시 적을 것**
정상적 상황 : 화살표 함수를 사용하여 `console.log('마라샹궈')`를 호출합니다. 이렇게 하면, 클릭이 발생할 때마다 새로운 함수 인스턴스가 생성되어 해당 로그를 출력합니다. 함수 인스턴스가 생성된다는 말은 JavaScript의 함수가 실행될 때마다 새로운 실행 컨텍스트가 생성된다는 것을 의미합니다.

JavaScript에서는 함수가 호출될 때마다 새로운 실행 컨텍스트가 스택에 푸시됩니다. 이 실행 컨텍스트는 함수의 실행에 필요한 모든 정보를 포함합니다. 여기에는 함수 내의 변수, 이 함수를 호출한 객체, 이 함수에서 반환해야 할 값 등이 포함됩니다.

위의 예에서 `onClick={()=>{console.log('마라샹궈')}}`는 함수를 정의하는 부분이며, 이 함수는 버튼을 클릭할 때마다 호출됩니다. 여기서 '새로운 함수 인스턴스가 생성된다'는 것은, 이 함수가 호출될 때마다 새로운 실행 컨텍스트가 생성되고, 이 실행 컨텍스트에서 `console.log('마라샹궈')`가 실행된다는 것을 의미합니다.

즉, 새로운 함수 인스턴스가 생성된다는 것은, 해당 함수의 실행에 필요한 새로운 환경(실행 컨텍스트)이 생성되고, 그 환경 내에서 함수의 코드가 실행된다는 것을 의미합니다.

---

1. `<button onClick={console.log('마라샹궈')}>`
   이게 바벨로 인해 해석되면 `React.createElement('button', {onClick: console.log('마라샹궈'})`가 될 거다. 이렇게 될 경우 버튼을 담은 컴포넌트가 로드되어서 버튼을 클릭했을 때가 아니라 버튼이 렌더링되는 시점에 바로 `console.log('마라샹궈')`가 실행되게 된다.

2. `onClick={clickHandler()}`
   이거 역시 똑같음
   (보충 필요)

---

만약 HTML 요소가 기본적으로 이벤트를 지원한다면 `on + 이벤트명`의 형태로 props를 추가해 이벤트 리스너를 달 수 있다.

보통 이런식으로 이벤트에서 트리거되고 핸들러 함수로 끝나는 경우가 많다.

## State

리액트의 동작 원리

- index.js에서 엔트리 포인트로 지정된 곳에 App.js가 렌더링됨
- App.js는 여러가지 하위 컴포넌트 코드들로 구성되어있음.
- 리액트는 그 하위 컴포넌트들을 하나하나 다 호출해서 JSX를 반환받음
- 이 일련의 과정들을 모두 마치고 난 뒤 전반적인 결과를 평가함
- 그걸 DOM 명령어로 번역 후 DOM에다가 반영시켜 렌더링함.

근데 문제는 리액트는 절대 반복하지 않는다는 것임. 즉 렌더링 되었을 때 위의 과정들을 실행하고 그 후에는 끝임. 근데 나는 화면에 보이는 걸 업데이트 하고 싶다. 그럴 때 쓰는 것이 State. 즉 특정 어떤 것이 변경되었고 특정 컴포넌트가 재평가되어야 한다고 말하는 문법.

이 기능을 사용하고 싶다면 `import { useState } from 'react'`를 해서 useState 함수를 불러와야 함. 컴포넌트 바깥에서 호출되거나, 혹은 중첩된 함수 안에서 호출할 수 없고 오직 컴포넌트 함수 안에서 직접적으로 호출되어야 함. 예외는 있긴 함. **(나중에 설명)**

> use로 시작하는 것들은 모두 훅임.

`const [name, setName] = useState('lee')`
저 두번째 set으로 시작하는 것으로 name을 바꿀 수 있음.
저걸 호출해서 값을 바꾸는 순간 리액트에게 state를 담고있는 컴포넌트의 재평가가 시급하다고 헬프콜을 때림.

```jsx
import { useState } from 'react';

export default function Test() {
  const [name, setName] = useState('lee');

  const clickHandler = () => {
    setName('kim');
    console.log(name);
  };

  return (
    <>
      <p>{name}</p>
      <button onClick={clickHandler}>이름 변경</button>
    </>
  );
}
```

위의 코드의 경우 버튼을 클릭하면 name이 바뀌기는 하지만 console.log(name)의 출력 값은 setName으로 바뀌기 이전의 state 값인 'lee'가 출력된다. 왜냐하면 state를 업데이트 하는 setName과 같은 함수들의 경우 바로 값을 바꾸지는 않고 state의 업데이트를 예약하기 때문임.

예를 들어 clickHandler의 함수가 요딴식으로 생겨먹었다고 가정해보자

```jsx
const clickHandler = () => {
  setName('kim');
  setName('park');
  setName('cha');
  setName('song');
  console.log(name);
};
```

만약 저런 setName이 호출되어 state가 변경되고 그 변경되는 즉시 컴포넌트를 재렌더링 하게 된다면 kim, park, cha, song으로 name이 변할 때마다 네 번의 렌더링이 발생하게 된다. 어차피 저 함수를 통해서 얻고 싶은건 name을 'song'으로 바꾼 한 번의 재렌더링이지 않은가. 그렇기 때문에 리액트에서는 set 함수로 state를 즉시 변경하는 게 아니라 예약(스케쥴링)해 성능을 최적화하고 일관성을 유지함. 이를 곧 batch update라고 칭함.

만약 강제로 업데이트 하고 싶다면 React 18 버전부터 추가된 flushSync()를 사용해 할 수 있음.

```jsx
export default function App() {
  return (
    <div>
      <Card name="lee" />
      <Card name="park" />
      <Card name="kim" />
    </div>
  );
}
```

```jsx
import { useState } from 'react';

export default function Card(props) {
  const [name, setName] = useState(props.name);
  const clickHandler = () => {
    setName('kim');
  };

  return (
    <>
      <p>{name}</p>
      <button onClick={clickHandler}>이름 변경</button>
    </>
  );
}
```

(저거를 실행한 결과 움짤)

Card라는 같은 컴포넌트를 참고해 렌더링 되었지만, 컴포넌트별 인스턴스를 기반으로 도립적인 state를 갖게되어 Card 컴포넌트 안에 정의된 state들은 자신만의 독립적인 state를 갖고 있다. 그래서 첫 번째 Card의 clickHandler를 작동시켰을 때 첫 번째 Card만 재렌더링 될 뿐 나머지 Card 컴포넌트는 그대로임. 왜냐하면 특정 인스턴스만 업데이트되고 나머지 다른 인스턴스는 상태 변화에 영향을 받지 않았기 때문임.
(여기서 컴포넌트 인스턴스는 특정 컴포넌트를 사용해 생성된 개별 엘리먼트를 말함. 컴포넌트 역시 일종의 틀임. 함수형이라서 조금 그렇지만 예전 class 문법에서는 이게 좀 더 직관적인 표현으로 와닿을 거임.)

---

근데 함수형 컴포넌트도 인스턴스라고 표현을 하는거니? 예전에 리액트에서 지원했던 클래스형 컴포넌트로 생성된 걸 보고 인스턴스라고 하는거면 이해가 가는데 함수형 컴포넌트에서도 인스턴스라는 말을 쓰는지 모르겠네

ChatGPT

JavaScript와 React에서 사용하는 '인스턴스' 개념은 약간 다릅니다. JavaScript에서 '인스턴스'는 클래스나 생성자 함수를 사용하여 생성된 객체를 의미합니다. 반면, React에서 '인스턴스'는 클래스 컴포넌트 또는 함수형 컴포넌트를 통해 생성된 개별 컴포넌트 엘리먼트를 의미합니다.

클래스형 컴포넌트에서 인스턴스는 더욱 명확하게 이해될 수 있습니다. 왜냐하면 JavaScript의 클래스에서 new 키워드를 사용하여 인스턴스를 생성하는 것과 유사하게, React 클래스 컴포넌트도 각기 다른 인스턴스를 생성하기 때문입니다. 이 경우, 각 인스턴스는 자체적인 상태(state)와 생명주기 메서드(lifecycle method)를 가집니다.

함수형 컴포넌트는 JavaScript 클래스가 아니지만, React의 컴포넌트 시스템 내에서 동일한 역할을 수행합니다. 함수형 컴포넌트의 각 호출은 효과적으로 새로운 '인스턴스'를 생성하며, 각 인스턴스는 독립적인 props, state, 그리고 hooks를 가집니다.

이렇게 설명하면, React에서 '인스턴스'라는 용어가 실제 JavaScript 객체 인스턴스와는 약간 다른 의미로 사용된다는 것을 이해하실 수 있을 것입니다. '인스턴스'라는 용어는 개별 컴포넌트 엘리먼트를 가리키는데, 이들 각각이 독립적인 상태와 동작을 가지는, 리액트 애플리케이션에서의 '인스턴스'를 의미하는 것입니다.

---

왜 const를 쓰느냐? useState()를 불러서 할당을 하는거임. `name = 'lee'` 이런 식으로 할당하지 않음. 그러므로 상수형으로 써도 괜찮음.

### 객체나 배열을 변경하고 싶을 때

```jsx
import { useState } from 'react';

export default function App(){
	// 이렇게 쓸 수도 있겠지만
	// const [name, setName] = useSTate('')
	// const [age, setAge] = useState(0)

	// 객체 형식으로 이렇게 묶었다고 쳐보자
	const [person, setPerson] = useState({
		name: '',
		age: 0
	})

	const nameHandler = (e) => {
		setPerson({...person, name: e.target.value })
	}

	const ageHandler = (e) => {
		setPerson({...person, age: e.target.value})
	}

	return (
		<form>
			<input type="text" onChange={nameHandler}>
			<input type="number" onChange={ageHandler}>
		</form>
	)
}
```

이럴 경우 저 객체를 업데이트 하는 방법은 저렇게 원래 값을 spread 연산자를 통해서 붙여넣고 덮어쓰고 싶은 값을 뒤에다가 써서 오버라이딩 하면 됨.

근데 이전 상태를 고려해야 하는 상황에서는 저렇게 쓰는 대신 setState 함수 안에 콜백 함수를 집어넣어 이전 상태를 기준으로 상태변경을 보장하는 로직으로 작성해야 함.

```jsx
import {useState} from 'react'

export default function App(){
	const [state, setState] = useState(0)
}

	const sum(){
		setState(state + 1);
		setState(state + 2);
		setState(state + 3);
		setState(state + 4);
	}

	const prevSum(){
		setState(prev => prev + 1);
		setState(prev => prev + 2);
		setState(prev => prev + 3);
		setState(prev => prev + 4);
	}

	return (
		<div>
			<p>결과: {state}</p>
			<button onClick={sum}>실행</button>
			// 실행시 4
		</div>
	)
```

이전값을 적용해서 모든 값을 적용시키고 싶다면 prevSum처럼 해야함

```
function personNameHandler(event){
	setPerson({...person, })
}

```

양방향 바인딩을 통해 유기적인 흐름을 만들어낼 수 있음. (ex: 제출 뒤 양식을 초기화시키고 싶을 때 state만 초기화 시켜버리면 알아서 양식 내용까지..)

## State + Props

만약 컴포넌트 구조가

- App
  - AddCardInput
  - Card

이렇다고 가정하자. 여기서 App에서 정의되어있는

```jsx
export default function App() {
  const [people, setPeople] = useState([
    { name: 'lee', age: 20 },
    { name: 'kim', age: 30 },
    { name: 'park', age: 40 },
  ]);

  return (
    <>
      <AddCardInput />
      {people.map((person, idx) => {
        <Card person={person} />;
      })}
    </>
  );
}
```

이렇게 되어있다고 치자. 여기서 AddCardInput 컴포넌트에서 상위 App 컴포넌트로 정보를 이동시키려면 어떻게 해야할까?

두 가지 방법이 있다.

1. App에 state를 만들어놓고 그걸 아래로 빼버리는 방법
2. AddCardInput에 핸들러 함수를 보내서 위로 빼내어 보내는 방법

```jsx
import { useState } from 'react';

export default function App() {
  const [people, setPeople] = useState([
    { name: 'lee', age: 20 },
    { name: 'kim', age: 30 },
    { name: 'park', age: 40 },
  ]);

  const savePersonDataHandler = personData => {
    setPeople(prev => [...prev, personData]);
  };

  return (
    <>
      <AddCardInput onSavePersonData={savePersonDataHandler} />
      {people.map((person, idx) => (
        <Card key={idx} person={person} />
      ))}
    </>
  );
}
```

```jsx
import { useState } from 'react';

export function AddCardInput({ onSavePersonData }) {
  const [name, setName] = useState('');
  const [age, setAge] = useState(0);

  const nameHandler = e => {
    setName(e.target.value);
  };

  const ageHandler = e => {
    setAge(e.target.value);
  };

  const submitHandler = e => {
    e.preventDefault();
    const personData = { name: name, age: age };
    onSavePersonData(personData);
    setName('');
    setAge(0);
  };

  return (
    <form onSubmit={submitHandler}>
      <input type="text" value={name} onChange={nameHandler} />
      <input type="number" value={age} onChange={ageHandler} />
      <button type="submit">제출</button>
    </form>
  );
}
```

## Presentational vs Stateful Components

```jsx title="app.jsx" showLineNumbers
import { useState } from 'react';
import AddCardInput from './AddCardInput';
import Card from './Card';
import './App.css';

function App() {
  const [people, setPeople] = useState([
    { name: 'lee', age: 20 },
    { name: 'kim', age: 30 },
    { name: 'park', age: 40 },
  ]);

  const savePersonDataHandler = personData => {
    setPeople(prev => [...prev, personData]);
  };

  return (
    <>
      <AddCardInput onSavePersonData={savePersonDataHandler} />
      {people.map((person, idx) => (
        <Card key={idx} person={person} />
      ))}
    </>
  );
}

export default App;
```

```jsx title="Card.jsx"
export default function Card({ person }) {
  return (
    <div>
      <p>이름: {person.name}</p>
      <p>나이: {person.age}</p>
    </div>
  );
}
```

여기서 App이나 AddCardInput과 같이 state가 존재하는 컴포넌트가 있는 반면, props를 받아 단순히 출력에만 기여하는 Card 컴포넌트와 같은 것들이 있음.
이렇게 state를 갖고있는 컴포넌트들을 Stateful, Smart 컴포넌트라고 부르고, state 없이 단순 출력에만 기여하는 컴포넌트들을 Stateless, Dumb, Presentational 컴포넌트라고 부름.

onClick과 같은 이벤트 리스너 프로퍼티에는 어떤 값을 전달해야 하나요?

- 이벤트가 발생했을 때 실행해야 하는 함수의 포인터

실행될 함수의 “포인터”를 onClick 등의 값으로 전달해야 합니다. 그러면 이벤트가 발생했을 때 “사용자를 대신하여” React가 함수를 실행합니다.

## map()을 활용한 코드 단축

>

#### (연구해야 됨) 왜 key를 넣어야 하는가?

[링크](https://velog.io/@yeonbot/React%EC%97%90%EC%84%9C-key%EC%9D%98-%EC%97%AD%ED%95%A0-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EB%A5%BC-%EB%8B%A4%EC%8B%9C%EA%B7%B8%EB%A6%AC%EB%8A%94-%EA%B3%BC%EC%A0%95)

## 조건문

조건을 단축하는 방법
name은 filteredName은 배열.

1. 삼항 연산자

```jsx
{
  filteredName.length === 0 ? <p>필터된 게 없슈</p> : <p>{/* 필터된 목록들 */}</p>;
}
```

2. && 연산자

```jsx
{ filteredName.length === 0 && /* 필터된게 없다는 안내문 */ }
{ filteredName.length > 0 && /* 필터된 목록들을 보여주기 */ }
```

3. 아예 JSX 문법 시작 전에 if로 미리 갈무리 쳐놓기

```jsx
let filterContents = <p>필터된 게 없슈</p>;

if (filteredName.length > 0) {
  filterContents = filterElements.map(/* 세부 내용 생략 */);
}

return (
  /* 생략 */
  { filterContents }
);
```

---

[^1]: 핵심 비즈니스 로직이 뭐지?
[^2]: 코드가 시작될 때 실행이 시작되는 파일. 가장 먼저 지나치는 통로같은 느낌.
[^3]: attribute와 property
